(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{512:function(t,v,_){"use strict";_.r(v);var e=_(4),a=Object(e.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h2",{attrs:{id:"设计模式的基本原则"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#设计模式的基本原则"}},[t._v("#")]),t._v(" 设计模式的基本原则")]),t._v(" "),_("ol",[_("li",[t._v("将变化的部分独立出来,进行封装,让那些不变的不易受到影响.")]),t._v(" "),_("li",[t._v("针对接口编程,而不是针对实现类.通过接口就无需知道方法实现的细节,只用根据需要调用.")]),t._v(" "),_("li",[t._v("多用组合,少用继承. 组合更具灵活性.")]),t._v(" "),_("li",[t._v("依赖抽象，不要依赖具体实现。 多用抽象类，而不是实现类。")])]),t._v(" "),_("h2",{attrs:{id:"uml语言"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#uml语言"}},[t._v("#")]),t._v(" UML语言")]),t._v(" "),_("h3",{attrs:{id:"定义"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#定义"}},[t._v("#")]),t._v(" 定义")]),t._v(" "),_("p",[t._v("UML：Unified Modeling Language， 统一建模语言，是用来设计软件蓝图的可视化建模语言，在设计模式中主要是能定义类图，类与类之间的关系。")]),t._v(" "),_("h3",{attrs:{id:"类"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#类"}},[t._v("#")]),t._v(" 类")]),t._v(" "),_("p",[t._v("类即我们常见的类定义结构，它封装了类的数据和方法。")]),t._v(" "),_("p",[t._v("1.类名，比如我们定义一个 Person 类表示人类。")]),t._v(" "),_("p",[t._v("2.属性，比如Person类有 - name:String 表示 私有属性name，类型是字符。")]),t._v(" "),_("blockquote",[_("p",[t._v("属性的声明格式是： [visible]attributeName:type[=defaultValue], 即 [可见性]属性名:类型[默认值]")])]),t._v(" "),_("p",[_("strong",[t._v("注意")]),t._v("：可见性是采用“+ - # ~ ” 四种符号表示的，依次表示：public，private，protected，friendly。")]),t._v(" "),_("p",[t._v("3.方法，比如Person类有方法 + eat():void，表示 公开方法 eat，无返回值。")]),t._v(" "),_("blockquote",[_("p",[t._v("方法的生命格式是：[visible]methodName(params):[returntype],即 [可见性]方法名(参数):返回类型")])]),t._v(" "),_("p",[_("strong",[t._v("注意")]),t._v("：方法的可见性同样是“+ - # ~ ”四种符号表示的，依次表示：public，private，protected，friendly。")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",[t._v("Class Person")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v('- name:String="Tom"')])]),t._v(" "),_("tr",[_("td",[t._v("- age:int=20")])]),t._v(" "),_("tr",[_("td",[t._v('- work:String="program developer"')])]),t._v(" "),_("tr",[_("td",[t._v("+ eat():void")])]),t._v(" "),_("tr",[_("td",[t._v("+ sleep():void")])])])]),t._v(" "),_("h3",{attrs:{id:"接口"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#接口"}},[t._v("#")]),t._v(" 接口")]),t._v(" "),_("p",[t._v("接口只包含了方法，而且通常都是public的。")]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",[t._v("Interface Skill")])])]),t._v(" "),_("tbody",[_("tr",[_("td",[t._v("+ cookie(Food):String")])]),t._v(" "),_("tr",[_("td",[t._v("+ learn():String")])])])]),t._v(" "),_("h3",{attrs:{id:"依赖关系"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#依赖关系"}},[t._v("#")]),t._v(" 依赖关系")]),t._v(" "),_("p",[t._v("UML中类图中类一类的关系按照耦合由弱到强，有如下几种：")]),t._v(" "),_("ul",[_("li",[t._v("依赖关系，")]),t._v(" "),_("li",[t._v("关联关系")]),t._v(" "),_("li",[t._v("聚合关系")]),t._v(" "),_("li",[t._v("组合关系")]),t._v(" "),_("li",[t._v("泛化关系（继承关系）")]),t._v(" "),_("li",[t._v("实现关系")])]),t._v(" "),_("p",[t._v("个人总结：")]),t._v(" "),_("p",[t._v("dependent-a是依赖关系，虚线箭头")]),t._v(" "),_("p",[t._v("associate-a是关联关系，实线实心三角形")]),t._v(" "),_("p",[t._v("contains-a是组合关系，实线实心菱形")]),t._v(" "),_("p",[t._v("has-a是聚合关系， 实线空心菱形")]),t._v(" "),_("p",[t._v("is-a是继承关系，实线空心三角形")]),t._v(" "),_("p",[t._v("implement-a是现实关系，虚线空心三角形")])])}),[],!1,null,null,null);v.default=a.exports}}]);