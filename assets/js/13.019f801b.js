(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{285:function(t,a,e){"use strict";e.r(a);var r=e(1),v=Object(r.a)({},function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"策略模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#策略模式","aria-hidden":"true"}},[t._v("#")]),t._v(" 策略模式")]),t._v(" "),e("h3",{attrs:{id:"类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#类型","aria-hidden":"true"}},[t._v("#")]),t._v(" 类型")]),t._v(" "),e("blockquote",[e("p",[t._v("对象行为模式")])]),t._v(" "),e("h3",{attrs:{id:"定义"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#定义","aria-hidden":"true"}},[t._v("#")]),t._v(" 定义")]),t._v(" "),e("blockquote",[e("p",[t._v("策略模式定义了一系列算法, 并将算法族分别封装起来, 让算法之间可以互相替换, 从而达到算法的变化独立于调用对象。")])]),t._v(" "),e("blockquote",[e("p",[t._v("理解：通过超类（接口或者抽象类）定义算法，并通过继承该超类封装成不同的算法，使得算法的使用和实现分割开来，达到解耦。而调用类则采用组合的方式，使用该算法对象。")])]),t._v(" "),e("h3",{attrs:{id:"结构和实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#结构和实现","aria-hidden":"true"}},[t._v("#")]),t._v(" 结构和实现")]),t._v(" "),e("p",[t._v("主要结构有：")]),t._v(" "),e("ol",[e("li",[t._v("抽象策略类（Strategy）：通过接口或者抽象类实现，它定义了一个公共的接口，不同的算法实现了这个接口。而上文类（Context）通过组合Strategy实例，调用该接口的各种实现算法。")]),t._v(" "),e("li",[t._v("具体策略类（ConcreteStrategy）： 实现了Strategy的接口，提供具体的算法。")]),t._v(" "),e("li",[t._v("上下文类（Context）： 持有抽象策略类的引用，给用户使用。")])]),t._v(" "),e("p",[t._v("UML关系： ConcreteStrategy 继承了 Strategy， Context 组合了 Strategy 。")]),t._v(" "),e("h3",{attrs:{id:"优点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#优点","aria-hidden":"true"}},[t._v("#")]),t._v(" 优点")]),t._v(" "),e("ol",[e("li",[t._v("多重条件逻辑不易维护，比如"),e("code",[t._v("if else")]),t._v("，"),e("code",[t._v("switch case")]),t._v("，采用策略模式可以避免使用多重条件语句。")]),t._v(" "),e("li",[t._v("策略模式提供的算法族，是可以替换和重用的。我们可以把一些公用的部分提取出来放到父类中，避免重复写代码。")]),t._v(" "),e("li",[t._v("策略模式提供了相同行为的不同实现，用户可以根据具体需求选择不同的算法，十分灵活。")]),t._v(" "),e("li",[t._v("策略模式符合开闭原则，对扩展开放，对修改闭合。")]),t._v(" "),e("li",[t._v("策略模式把算法的使用放到了调用类中，把算法实现放到了具体策略类中，达到了解耦。")])]),t._v(" "),e("h3",{attrs:{id:"缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缺点","aria-hidden":"true"}},[t._v("#")]),t._v(" 缺点")]),t._v(" "),e("ol",[e("li",[t._v("用户必须知道各种算法的区别，才能正确的选择需要的算法。")]),t._v(" "),e("li",[t._v("算法过多，会造成策略类泛滥。")])]),t._v(" "),e("h3",{attrs:{id:"使用场景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用场景","aria-hidden":"true"}},[t._v("#")]),t._v(" 使用场景")]),t._v(" "),e("ol",[e("li",[t._v("多重条件语句来实现多种行为时。")]),t._v(" "),e("li",[t._v("系统中各个算法彼此独立，对客户端不展示具体实现时。")]),t._v(" "),e("li",[t._v("运行时动态的选择需要执行的算法。")])]),t._v(" "),e("h3",{attrs:{id:"扩展"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#扩展","aria-hidden":"true"}},[t._v("#")]),t._v(" 扩展")]),t._v(" "),e("blockquote",[e("p",[t._v("多种类型的策略类，可以采用工厂方法模式，管理策略类的创建。")])])])},[],!1,null,null,null);a.default=v.exports}}]);