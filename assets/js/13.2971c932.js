(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{284:function(t,a,e){"use strict";e.r(a);var r=e(1),v=Object(r.a)({},function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h2",{attrs:{id:"设计模式的基本原则"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#设计模式的基本原则","aria-hidden":"true"}},[t._v("#")]),t._v(" 设计模式的基本原则")]),t._v(" "),e("ol",[e("li",[t._v("将变化的部分独立出来,进行封装,让那些不变的不易受到影响.")]),t._v(" "),e("li",[t._v("针对接口编程,而不是针对实现类.通过接口就无需知道方法实现的细节,只用根据需要调用.")]),t._v(" "),e("li",[t._v("多用组合,少用继承. 组合更具灵活性.")]),t._v(" "),e("li",[t._v("依赖抽象，不要依赖具体实现。 多用抽象类，而不是")])]),t._v(" "),e("blockquote",[e("h2",{attrs:{id:"策略模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#策略模式","aria-hidden":"true"}},[t._v("#")]),t._v(" 策略模式")])]),t._v(" "),e("blockquote",[e("h3",{attrs:{id:"类型："}},[e("a",{staticClass:"header-anchor",attrs:{href:"#类型：","aria-hidden":"true"}},[t._v("#")]),t._v(" 类型：")])]),t._v(" "),e("p",[t._v("对象行为模式")]),t._v(" "),e("blockquote",[e("h3",{attrs:{id:"定义"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#定义","aria-hidden":"true"}},[t._v("#")]),t._v(" 定义")])]),t._v(" "),e("p",[t._v("策略模式定义了一系列算法, 并将算法族分别封装起来, 让算法之间可以互相替换, 从而达到算法的变化独立于调用对象。")]),t._v(" "),e("p",[t._v("理解：通过超类（接口或者抽象类）定义算法，并通过实现继承该超类封装成不同的算法，使得算法的使用和实现分割开来，达到解耦。而调用类则采用组合的方式，使用该算法对象。")]),t._v(" "),e("blockquote",[e("h3",{attrs:{id:"优点："}},[e("a",{staticClass:"header-anchor",attrs:{href:"#优点：","aria-hidden":"true"}},[t._v("#")]),t._v(" 优点：")])]),t._v(" "),e("ol",[e("li",[t._v("多重条件逻辑不易维护，比如"),e("code",[t._v("if else")]),t._v("，"),e("code",[t._v("switch case")]),t._v("，采用策略模式可以避免使用多重条件语句。")]),t._v(" "),e("li",[t._v("策略模式提供的算法族，是可以替换和重用的。我们可以把一些公用的部分提取出来放到父类中，避免重复写代码。")]),t._v(" "),e("li",[t._v("策略模式提供了相同行为的不同实现，用户可以根据具体需求选择不同的算法，十分灵活。")]),t._v(" "),e("li",[t._v("策略模式符合开闭原则，对扩展开放，对修改闭合。")]),t._v(" "),e("li",[t._v("策略模式把算法的使用放到了调用类中，把算法实现放到了具体策略类中，达到了解耦。")])]),t._v(" "),e("blockquote",[e("h3",{attrs:{id:"缺点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#缺点","aria-hidden":"true"}},[t._v("#")]),t._v(" 缺点:")])]),t._v(" "),e("ol",[e("li",[t._v("用户必须知道各种算法的区别，才能正确的选择需要的算法。")]),t._v(" "),e("li",[t._v("算法过多，会造成策略类泛滥。")])]),t._v(" "),e("blockquote",[e("h3",{attrs:{id:"结构和实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#结构和实现","aria-hidden":"true"}},[t._v("#")]),t._v(" 结构和实现")])]),t._v(" "),e("p",[t._v("主要结构有：")]),t._v(" "),e("ol",[e("li",[t._v("抽象策略类（Strategy）：通过接口或者抽象类实现，它定义了一个公共的接口，不同的算法实现了这个接口。而上文类（Context）通过组合Strategy实例，调用该接口的各种实现算法。")]),t._v(" "),e("li",[t._v("具体策略类（ConcreteStrategy）： 实现了Strategy的接口，提供具体的算法。")]),t._v(" "),e("li",[t._v("上下文类（Context）： 持有抽象策略类的引用，给用户使用。")])]),t._v(" "),e("p",[t._v("UML语句： ConcreteStrategy 实现了 Strategy， Context 组合了 Strategy 。")]),t._v(" "),e("blockquote",[e("h3",{attrs:{id:"使用场景："}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用场景：","aria-hidden":"true"}},[t._v("#")]),t._v(" 使用场景：")])]),t._v(" "),e("p",[t._v("1、多重条件语句来实现多种行为时\n2、系统中各个算法彼此独立，对客户端不展示具体实现时。\n3、运行时动态的选择需要执行的算法。")]),t._v(" "),e("blockquote",[e("h3",{attrs:{id:"扩展"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#扩展","aria-hidden":"true"}},[t._v("#")]),t._v(" 扩展")])]),t._v(" "),e("p",[t._v("多种类型的策略类，可以采用工厂方法模式，管理策略类的创建。")])])},[],!1,null,null,null);a.default=v.exports}}]);